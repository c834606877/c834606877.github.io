---
layout: post
title: CISCN(2018)逆向之task-reverse_06

categories:
- Linux
- 逆向
- CTF

tags: [CTF， 逆向]

author:
  login: lanbing
  email: c834606877@163.com
---





午睡的时候，朋友发来个题，反正闲也闲着，来练练手。



##  #1 查壳

拿到程序先确认使用的是什么编译器，什么环境下运行，以决定用何种工具。

![1525058201289](/post_res/2018-04-09-task-reverse_06.assets/1525058201289.png)

程序无花无壳，直接上IDA静态了，CTF的题在实机调比较方便。

<!--more-->

## #2 程序入口 

main函数特征也很轻易识别出来了

![1525059332073](/post_res/2018-04-09-task-reverse_06.assets/1525059332073.png)



函数体内容简短，结构清析。

首先，读取输入流32个字节的flag，匹配可知，flag 形式为CISCN{xxxx_xxxx_xxxx}

![1525059535892](/post_res/2018-04-09-task-reverse_06.assets/1525059535892.png)

内容以下划线划分为三个文本段，

分别将文本仍扔进函数`sub_4012DE、sub_401411、sub_401562`进行效验。

接下来就是分析，这个三个函数的逻辑了。

暂且先将函数分别命名为`check_1,check_2,check_3`



## #3 逻辑分析check_1

来到函数check_1

![1525075523089](/post_res/2018-04-09-task-reverse_06.assets/1525075523089.png)

作者对md5加密函数的初始化做了些许修改，四个幻数并非直接给出，好在没有过多修改md5计算的部分，顺利分析出几个md5函数功能。

关键在于，将文本MD5加密后，对密文再次进行了运算，伪代码如下所示：

```c
for(int i=0; i< strlen(md5_str); i++)
{
    if(md5_str[i] >= 'A' && md5_str[i] <= 'F')
        md5_str[i] += i%10;
}
```

进行上述运算后，进行 再与给定密文进行比较`5BH8170528842F510K70EGH31F44M24B`。

由此第一个文本串逆向方法为

```c
for(int i=0; i< strlen(md5_str_mixed); i++)
{
    if(md5_str_mixed[i] >= 'A' )
        md5_str_mixed[i] -= i%10;
}

```

得到`MD5_HASH(flag_1) = 5AF8170528842C510D70EFF31A44E24A`

查表可得，`flag_1 =tima `



## #4 逻辑分析check_2

第二个校验函数与前一个如出一辙

![1525076540084](/post_res/2018-04-09-task-reverse_06.assets/1525076540084.png)

程序仅在算出md5_hex后，将16字节的hash值与给定数据进行与运算，得到结果，再进行`hex2str`相关代码逆向代码如下，不再赘述:

```c
unsigned char byte_603860[16] = {0x92,  0x84,  0x3D,  0xA7,  0x14,  0xF2,  0xFB,  0x4B,  0xEE,  0x8A,  0xC2,  0xC3,  0x76,  0x68,  0x13,  0x1E};

for(int i=0; i< 16; i++)
{
    md5_hex[i] ^=byte_603860[i];
}
```

查表得到第二个文本串内容为`flag_2="yefb"`



## #4 逻辑分析check_3

而第三段校验函数较为复杂，前半段内容，与前check_1,check_2一样，但如法炮制逆向出的MD5却查不到表。

此时，得到的部分flag为`CISCN{tima_yefb_????????????}`，仍有15个字符未知。

倒也不奇怪，一串长为15的字符串查不到，实属正常，此路可能不通。

接着往下看，

![1525077666173](/post_res/2018-04-09-task-reverse_06.assets/1525077666173.png)

接着，写出一个大小为6002的文件，内容分奇偶进行简单解密，而密钥却是第三串的第三和第四个字符有关，这是何意？

到现在为止，有关第三串的信息只有知道长度和MD5，这是不可能有第三串任何具体内容的。

此路也不通，可能需要另辟蹊径了。

看看这6002大小的文件长什么样，实在不行，密钥区区万种组合，也可以直接爆破也是一种可能的办法。

一个正常的文件被加密成这个样子，好像可以发现一此东西。

![1525078262851](/post_res/2018-04-09-task-reverse_06.assets/1525078262851.png)

嗯，连续的`9n9n`引起了我的注意，由于分奇偶加密，9和n应该是代表的同一个内容，这很可能是一些文件头定义中的缺省值00之类的，在尝试了可能对应`0x00` 或者`0x32`的之后，确定了这很可能是一张jpg图片，而jpg文件头，第5~8个字节内容对应为`JFIF`。

得到解密内容为：

![flag](/post_res/2018-04-09-task-reverse_06.assets/ciscn-2018-flag.jpg)

内容正好为15位，拼凑成一块，得到最后的flag为：

`CISCN{tima_yefb_MayDetyU$hhtIm2}`

## 总结

这个题目，在最后一关，不按套路出牌，无中生有的将结果关联到flag，很容易将人引入歧途，迷惑解题者，但也是出于在命题规则范围内的操作，无可厚非。

前两步相对简单，有助于提高一部分初学者的安全兴趣。以小见大，这类型的比赛，仍然是以宣传网络安全为主，为从国家层面提高全民安全意识起到促进作用。

遥想十年前，京城奥运期间，大部分小作坊式安全论坛顷刻倒塌，消亡殆尽。昔日像华夏，暗组，黑基，X Files，F4等一批优秀论坛虽已辉煌不再。正是那个时候，他们帮助了笔者对计算机的启蒙。历史的车轮滚滚向前，穿过岁月的云烟，今天，以提高全民安全意识的运动，得以在阳光下绽放光彩。



